From 6e68642267d3b02aa119910a6991c83fb8493bbd Mon Sep 17 00:00:00 2001
From: wangzhengyong <wangzhengyong@cmss.chinamobile.com>
Date: Mon, 21 Nov 2016 16:39:35 +0800
Subject: [PATCH] sheepdog: add reconnect to cluster

---
 block/sheepdog.c | 174 ++++++++++++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 159 insertions(+), 15 deletions(-)

diff --git a/block/sheepdog.c b/block/sheepdog.c
index 33e0a33..a5555bc 100644
--- a/block/sheepdog.c
+++ b/block/sheepdog.c
@@ -23,6 +23,7 @@
 #include "qemu/cutils.h"
 
 #define SD_PROTO_VER 0x01
+#define SD_SHEEP_PROTO_VER 0x09
 
 #define SD_DEFAULT_ADDR "localhost"
 #define SD_DEFAULT_PORT 7000
@@ -73,6 +74,9 @@
 #define SD_RES_JOIN_FAILED   0x18 /* Target node had failed to join sheepdog */
 #define SD_RES_HALT          0x19 /* Sheepdog is stopped serving IO request */
 #define SD_RES_READONLY      0x1A /* Object is read-only */
+#define SD_RES_KILLED       0x8D /* Node is killed */
+
+#define SD_OP_GET_NODE_LIST  0x82
 
 /*
  * Object ID rules
@@ -110,6 +114,45 @@
 #define LOCK_TYPE_NORMAL 0
 #define LOCK_TYPE_SHARED 1      /* for iSCSI multipath */
 
+struct rb_node {
+    unsigned long  rb_parent_color __attribute__ ((aligned (8)));
+#define RB_RED          0
+#define RB_BLACK        1
+    struct rb_node *rb_right __attribute__ ((aligned (8)));
+    struct rb_node *rb_left __attribute__ ((aligned (8)));
+};
+
+struct rb_root {
+    struct rb_node *rb_node;
+};
+
+struct node_id {
+    uint8_t addr[16];
+    uint16_t port;
+    uint8_t io_addr[16];
+    uint16_t io_port;
+    uint8_t pad[4];
+};
+
+struct disk_info {
+    uint64_t disk_id;
+    uint64_t disk_space;
+};
+
+#define DISK_MAX     32
+#define WEIGHT_MIN   (1ULL << 32)       /* 4G */
+
+struct sd_node {
+    struct rb_node  rb;
+    struct node_id  nid;
+    uint16_t nr_vnodes;
+    uint32_t zone;
+    uint64_t space;
+    #define SD_MAX_NODES 6144
+    #define SD_NODE_SIZE 80
+    struct disk_info disks[0];
+};
+
 typedef struct SheepdogReq {
     uint8_t proto_ver;
     uint8_t opcode;
@@ -120,6 +163,11 @@ typedef struct SheepdogReq {
     uint32_t opcode_specific[8];
 } SheepdogReq;
 
+struct sheep_host {
+    char addr[INET_ADDRSTRLEN];
+    uint32_t port;
+};
+
 typedef struct SheepdogRsp {
     uint8_t proto_ver;
     uint8_t opcode;
@@ -377,6 +425,10 @@ typedef struct BDRVSheepdogState {
     bool is_unix;
     int fd;
 
+    struct sheep_host *hosts;
+    uint32_t nr_hosts;
+    uint32_t host_index;
+
     CoMutex lock;
     Coroutine *co_send;
     Coroutine *co_recv;
@@ -740,6 +792,40 @@ static void coroutine_fn resend_aioreq(BDRVSheepdogState *s, AIOReq *aio_req);
 static int reload_inode(BDRVSheepdogState *s, uint32_t snapid, const char *tag);
 static int get_sheep_fd(BDRVSheepdogState *s, Error **errp);
 static void co_write_request(void *opaque);
+static coroutine_fn void do_reconnect(void *opaque)
+{
+    int retry;
+    BDRVSheepdogState *s = opaque;
+    struct sheep_host *p = NULL;
+
+    if (s->fd < 0)
+        g_free(s->host_spec);
+
+    while (s->fd < 0) {
+        Error *local_err = NULL;
+        retry = s->nr_hosts;
+        while (retry--) {
+            p = s->hosts + s->host_index;
+            s->host_spec = g_strdup_printf("%s:%d", p->addr, p->port);
+            DPRINTF("reconnecting to %s \n", s->host_spec);
+            s->host_index = (s->host_index + rand()) % s->nr_hosts;
+            s->fd = get_sheep_fd(s, &local_err);
+            if (s->fd < 0) {
+                error_report_err(local_err);
+                error_free(local_err);
+                g_free(s->host_spec);
+                co_aio_sleep_ns(bdrv_get_aio_context(s->bs), QEMU_CLOCK_REALTIME,
+                    1000000000ULL);
+
+            } else {
+                DPRINTF("reconnected to [%d]:%s \n", s->host_index, s->host_spec);
+                break;
+            }
+    }
+}
+
+return;
+}
 
 static coroutine_fn void reconnect_to_sdog(void *opaque)
 {
@@ -756,17 +842,7 @@ static coroutine_fn void reconnect_to_sdog(void *opaque)
         co_write_request(opaque);
     }
 
-    /* Try to reconnect the sheepdog server every one second. */
-    while (s->fd < 0) {
-        Error *local_err = NULL;
-        s->fd = get_sheep_fd(s, &local_err);
-        if (s->fd < 0) {
-            DPRINTF("Wait for connection to be established\n");
-            error_report_err(local_err);
-            co_aio_sleep_ns(bdrv_get_aio_context(s->bs), QEMU_CLOCK_REALTIME,
-                            1000000000ULL);
-        }
-    };
+    do_reconnect(s);
 
     /*
      * Now we have to resend all the request in the inflight queue.  However,
@@ -819,7 +895,6 @@ static void coroutine_fn aio_read_response(void *opaque)
         }
     }
     if (!aio_req) {
-        error_report("cannot find aio_req %x", rsp.id);
         goto err;
     }
 
@@ -895,6 +970,10 @@ static void coroutine_fn aio_read_response(void *opaque)
         }
         resend_aioreq(s, aio_req);
         goto out;
+    /* fall through */
+    case SD_RES_KILLED:
+        resend_aioreq(s, aio_req);
+        goto out;
     default:
         acb->ret = -EIO;
         error_report("%s", sd_strerror(rsp.result));
@@ -1316,7 +1395,7 @@ static int reload_inode(BDRVSheepdogState *s, uint32_t snapid, const char *tag)
 
     fd = connect_to_sdog(s, &local_err);
     if (fd < 0) {
-        error_report_err(local_err);
+        error_free(local_err);
         return -EIO;
     }
 
@@ -1324,7 +1403,7 @@ static int reload_inode(BDRVSheepdogState *s, uint32_t snapid, const char *tag)
 
     ret = find_vdi_name(s, s->name, snapid, tag, &vid, false, &local_err);
     if (ret) {
-        error_report_err(local_err);
+        error_free(local_err);
         goto out;
     }
 
@@ -1410,6 +1489,67 @@ static QemuOptsList runtime_opts = {
     },
 };
 
+static int sd_get_nodes(BDRVSheepdogState *s, Error **errp)
+{
+    int ret;
+    struct sd_node *nodes = NULL;
+    SheepdogVdiReq hdr;
+    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;
+    int fd;
+    unsigned int wlen = 0, rlen = 0;
+    unsigned int nodes_size;
+    int i;
+
+    nodes_size = SD_MAX_NODES * sizeof(struct sd_node);
+    nodes = g_malloc(nodes_size);
+
+    fd = connect_to_sdog(s, errp);
+    if (fd < 0) {
+        ret = -EIO;
+        goto out;
+    }
+
+    rlen = nodes_size;
+
+    memset(&hdr, 0, sizeof(hdr));
+    hdr.opcode = SD_OP_GET_NODE_LIST;
+    hdr.proto_ver = SD_SHEEP_PROTO_VER;
+    hdr.data_length = rlen;
+
+    ret = do_req(fd, s->aio_context, (SheepdogReq *)&hdr,
+                nodes, &wlen, &rlen);
+
+    closesocket(fd);
+    if (ret) {
+        goto out;
+    }
+
+    if (rsp->result == SD_RES_SUCCESS) {
+        int nr_nodes = rsp->data_length / sizeof(struct sd_node);
+        s->hosts = g_malloc(nr_nodes * sizeof(struct sheep_host));
+        s->nr_hosts = nr_nodes;
+        s->host_index = 0;
+        for (i = 0; i < nr_nodes; i++) {
+            struct sheep_host *p = s->hosts + i;
+            p->port = nodes[i].nid.port;
+            if (!inet_ntop(AF_INET, nodes[i].nid.addr + 12,
+                p->addr, INET_ADDRSTRLEN)) {
+                g_free(s->hosts);
+                ret = SD_RES_SYSTEM_ERROR;
+                goto out;
+            }
+            DPRINTF("get sheep node %s:%d \n", s->hosts[i].addr, s->hosts[i].port);
+        }
+    } else {
+        ret = rsp->result;
+        g_free(s->hosts);
+    }
+
+out:
+    g_free(nodes);
+    return ret;
+}
+
 static int sd_open(BlockDriverState *bs, QDict *options, int flags,
                    Error **errp)
 {
@@ -1472,7 +1612,7 @@ static int sd_open(BlockDriverState *bs, QDict *options, int flags,
     if (flags & BDRV_O_NOCACHE) {
         s->cache_flags = SD_FLAG_CMD_DIRECT;
     }
-    s->discard_supported = true;
+    s->discard_supported = false;
 
     if (snapid || tag[0] != '\0') {
         DPRINTF("%" PRIx32 " snapshot inode was open.\n", vid);
@@ -1497,6 +1637,10 @@ static int sd_open(BlockDriverState *bs, QDict *options, int flags,
     }
 
     memcpy(&s->inode, buf, sizeof(s->inode));
+    ret = sd_get_nodes(s, errp);
+    if (ret) {
+        goto out;
+    }
 
     bs->total_sectors = s->inode.vdi_size / BDRV_SECTOR_SIZE;
     pstrcpy(s->name, sizeof(s->name), vdi);
-- 
1.8.3.1

